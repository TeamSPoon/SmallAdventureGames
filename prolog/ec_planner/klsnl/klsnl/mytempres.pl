/*
This program controls the temporal resolution part of the temporal resolution
theorem prover. To use the theorem prover start up sicstus by typing
"sicstus" and at the promt type [rules, snff, nontemp, tempres, fullres].
(or whatever the programs are called at this moment) which will load the
programs.

This program is called from fullres.pl which drives the resolution cycle of
             1. Translation to SNF
             2. Non temporal resolution
             3. Temporal resolution
*/

/*****************************************************************************/
/* tempres(Rules, ERulePaths, NewERule, RelatedRules,RulesUsed, LoopPath).   */
/*                                                                           */
/* Takes a list of rules output by SNF (Rules), which have been subsequently */
/* numbered and have a record of the numbers oftheir parent resolvents,      */
/* ie. they are in the form          r(Number, FromList, Text)          and  */
/* after attempts at non temporal resolution have been exhausted, tries      */
/* temporal resolution. ERulePaths contains a list made up of sublists. Each */
/* sublist has an eventuality which has been taken from the global and       */
/* initial sometimes rules and a list of previous paths detected. Thus       */
/* ERulePaths is of the form [[p,[]],[neg q,[]]] if we have only two         */
/* sometimes rules which may be  a imp sometime neg p and               */
/* wlast false imp sometime q, say.                                          */
/* Currently in this example no loops have been found so the list containing */
/* paths previously detected in each case is empty. The program attempts to  */
/* find a loop in an eventuality form this list. It first tries to look for  */
/* a loop for the first eventuality in the ERulePaths list (in our example p)*/
/* If the program detects a loop which has not been found before it returns  */
/* the eventuality (p) in the variable NewERule and the loop it has found in */
/* LoopPath. If no new loops are found in the first eventuality in the       */
/* ERulePaths list the progam looks for loops in the second, third etc until */
/* a new loop is found or no new loops can be found.                         */
/* RelatedRules are the set of rules of the form  R imp next p, where p is   */
/* the current eventuality, and RulesUsed contains a list of the numbers of  */
/* rules used in this loop.                                                  */
/*                                                                           */
/*****************************************************************************/

/* Related rules are the new clauses generated by temporal resolution */

tempres(Rules,[[ERule,PrevPath]|ERulePaths],NewERule,RelatedRules,RulesUsed,LoopPath):-
  temp_resolution(ERule,ERulePaths,Rules,PrevPath,NewERule,RelatedRules,RulesUsed,LoopPath).


/*****************************************************************************/
/* temp_resolution(ERule, ERulePaths, Rules, PrevPaths, NewERule,            */
/*                                        RelatedRules,RulesUsed, LoopPath)  */
/*                                                                           */
/* Takes an eventuality ERule (say p), a list of loops previously found for  */
/* this eventuality (PrevPaths), a list of the remaining eventualities       */
/* paired with loops which have been found previously (ERulePaths), and the  */
/* list of rules (Rules) which have been output from previous cycles of      */
/* temporal and non temporal resolution. The global box rules are extracted  */
/* from Rules and then the program looks for new loops in ERule from these   */
/* global box rules. If a new loop is found in ERule the loop is returned in */
/* LoopPath and the eventuality it matches is returned in NewERule. If no    */
/* loop is found for this ERule the first eventuality and list of previous   */
/* paths is stripped from the front of ERulePaths and a new loop is looked   */
/* in this new eventuality.                                                  */
/* RelatedRules are the set of rules of the form  R imp next p, where p is   */
/* the current eventuality, and RulesUsed contains a list of the numbers of  */
/* rules used in this loop.                                                  */
/*                                                                           */
/*****************************************************************************/

temp_resolution(ERule,ERulePaths,Rules,PrevPaths,NewERule,RelatedRules,RulesUsed,NewLoopPath):-
  my_writef('Attempting temporal resolution with %t.\n',[ERule]),
  resolve_eventuality(ERule, Rules, RelatedRules1,RulesUsed1,LoopPath),   
  test_path(ERule,ERulePaths,Rules,PrevPaths,LoopPath,NewERule,RelatedRules1,RulesUsed1,RelatedRules,RulesUsed,NewLoopPath).

/*****************************************************************************/
/*   test_path(ERule,ERulePaths, Rules, PrevPaths, LoopPath, NewERule,       */
/*         RelatedRules1,RulesUsed1, RelatedRules,RulesUsed, NewLoopPath).   */
/*                                                                           */
/* Checks to see whether we need to do any more temporal resolution or not.  */
/* We terminate without having found a loop (NewLoopPath is empty) if there  */
/* are no more eventualities to deal with (ERulePaths is empty) and if we    */
/* detected a loop this time (LoopPath is empty) or we have detected a loop  */
/* which is the same a a previous loop. Otherwise we recursively call        */
/* temp_resolution with the next eventuality on the ERulePaths list          */
/* with a loop if we detect a loop that is not the same as a loop we have    */
/* before for this eventuality.                                              */
/*                                                                           */
/*****************************************************************************/

                       % Last loop detected was empty and there are no eventualities
                       % left to process.

test_path(_,[],_Rules,_,[],_NewERule,_,_,[],[],[]):- !.

                       % Last loop detected was empty so look for loops for the
                       % next eventuality.

test_path(_,[[ERule,PrevPath]|ERulePaths], Rules,_,[],NewERule,_,_,RelatedRules,RulesUsed,LoopPath):- !,
   temp_resolution(ERule,ERulePaths,Rules,PrevPath,NewERule,RelatedRules,RulesUsed,LoopPath).

                       % Last loop was the same as one we found previously and
                       % there are no eventualities left to process.

test_path(_,[],_Rules,PrevPath1,LoopPath,_NewERule,_,_,[],[],[]):-
   same_node_in_list(PrevPath1,LoopPath),!.

                       % Last loop found was the same as one we found previously
                       % so look for loops for the next eventuality.

test_path(_,[[ERule,PrevPath]|ERulePaths],Rules,PrevPath1,LoopPath,NewERule,_,_,RelatedRules,RulesUsed,NewLoopPath):-
   same_node_in_list(PrevPath1,LoopPath),!,
   temp_resolution(ERule,ERulePaths,Rules,PrevPath,NewERule,RelatedRules,RulesUsed,NewLoopPath).

                       % We have found a new loop that is not empty and is not the
                       % same as a loop we have found earlier for this eventuality
                       % so return this new loop.

test_path(ERule,_, _, _, LoopPath,ERule,RelatedRules,RulesUsed,RelatedRules,RulesUsed,LoopPath).


/*****************************************************************************/
/* same_node_in_list(PrevLoops,LoopPath)                                     */
/*                                                                           */
/* This checks to see whether The new loop we have found LoopPath is the     */
/* as any of the loops we have found already PrevLoops.                      */ 
/*                                                                           */
/*****************************************************************************/

same_node_in_list([PrevLoop|_],LoopPath):-
   same_node(PrevLoop,LoopPath),!.

same_node_in_list([_|PrevLoops],LoopPath):-
   same_node_in_list(PrevLoops,LoopPath).

/*****************************************************************************/
/* resolve_eventuality(Eventuality, Rules, RelatedRules,RulesUsed, LoopPath) */
/*                                                                           */
/* Takes a single eventuality (Eventuality), and a list of Global Box Rules  */
/* (Rules), negates the eventuality (Eventuality), and finds a list of rules */
/* which imply this proposition. The lhs of these rules are added as initial */
/* nodes in graph, and a loop through the graph is searched for starting     */
/* from the top node which is the simplified disjunction of the left hand    */
/* sides of these initial nodes. A graph is built by looking for the largest */
/* set of rules (or combinations of rules whose left hand side imply the     */
/* previous node and whose right hand side imply the top node.               */
/* RelatedRules are the set of rules of the form  R imp p, where p is   */
/* the current eventuality, and RulesUsed should contain a list of the       */
/* numbers of rules used in this loop. Unfortunately this has not yet been   */
/* coded properly but has been left in returning [] in the hope that it will */
/* be fixed. All the related rules are for is for generating the proof at the*/
/* end.                                                                      */
/*                                                                           */
/*****************************************************************************/

                       % Note RulesUsed is set to [] !

resolve_eventuality(F,Others, RelatedRules,[], LoopList):-      
   snff_negate(F, NewF),                  % Negates F (ie ~F  --> F, and F --> ~F)
   relatedrules(NewF, Others, RelatedRules, NewOthers),   
   write_ruleset(RelatedRules),
   write_ruleset(NewOthers),
   add_initial(RelatedRules, OrigNodes), !,                
   simplify_top_node(F,OrigNodes,SimplerOrig),
   build_graph(F,Others, SimplerOrig,SimplerOrig, LoopList).       

/*****************************************************************************/
/* related_rules(Prop, [Rule|RuleList], RelatedRules, RemainingRules)        */
/*                                                                           */
/* This predicate takes a proposition, the negation of the proposition,      */
/* relating to the current eventuality, and a list of rules which are global */
/* box rules. It searches these rules for rules implying the eventuality,    */
/* returning them in RelatedRules.                                           */
/* Note relatedrules will not include rules which have Prop as part of a     */
/* disjunction on the rhs of the implication, or those which have            */
/* wlast false on the lhs of the implication ie wlast false => Prop.         */
/*****************************************************************************/

relatedrules(Prop, [r(N1,N2,P imp next Prop)|RuleList], [r(N1,N2, P imp next Prop)|RelatedRules], RemainingRules):- !,
   relatedrules(Prop, RuleList, RelatedRules, RemainingRules).

relatedrules(Prop, [r(N1,N2,Prop)|RuleList], [r(N1,N2, Prop)|RelatedRules], RemainingRules):- 
   disjunction_of_literals(Prop),!,
   relatedrules(Prop, RuleList, RelatedRules, RemainingRules).

relatedrules(Prop, [Rule|RuleList], RelatedRules, [Rule|RemainingRules]):-
   relatedrules(Prop, RuleList, RelatedRules, RemainingRules).

relatedrules(_,[],[],[]).        

/*****************************************************************************/
/* add_initial(Rules, Nodes)                                                 */
/*                                                                           */
/* Takes a list of rules which imply the negation of the current eventuality */
/* and returns a list with the rhs of these rules as a list of nodes.        */
/* eg a list of rules [ a imp p,  b imp next p,  a & c imp next p]           */
/* would return a node list of the form [[a], [b], [a,c]]                    */
/*                                                                           */
/*****************************************************************************/

add_initial([r(_,_, F imp next _)|Rules], [StrippedF |Nodes]):-
   strip(F, StrippedF),
   add_initial(Rules, Nodes).

add_initial([r(_,_, F)|Rules], [[true] |Nodes]):-
   disjunction_of_literals(F),
   add_initial(Rules, Nodes).

add_initial([], []).

/*****************************************************************************/
/* build_graph(F,Rules, OrigNodes, RulesUsed,Solution)                         */
/*                                                                           */
/* Takes current set of Rules (will be Global Box Rules without rules        */
/* implying current eventuality), the set of OrigNodes (the Original Nodes   */
/* the graph), the negation of the current eventuality (OurP). It returns    */
/* and returns the loop detected if one has been found in Solution and       */
/* should store the numbers of the rules it used to detect the loop in       */
/* RulesUsed but this is not implemented correctly yet. Build graph          */
/* when either the new node is "true", the last two nodes are equivalent, or */
/* the new node is empty.                                                    */
/*                                                                           */
/*****************************************************************************/

                    % Top node has been simplified to "true"
      
build_graph(_,_,_,[[true]],[[true]]):- !.

build_graph(F,Rules, PrevNode, TopNode,FinalNode):- 
      writef('\nThe New Node is %t.\n',[PrevNode]),
      build_node(F,Rules, PrevNode,TopNode,NewNode),!,
      test_newnode(F,Rules, PrevNode, TopNode,NewNode,FinalNode).

/*****************************************************************************/
/* test_newnode(Rules, PrevNode, TopNode,NewNode,FinalNode).                 */
/*                                                                           */
/* Checks termination conditions for build graph. We stop recalling          */
/* build_graph if the new node (NewNode) is empty returning with an empty    */
/* loop. We terminate if our new node has been simplified to "true" or if    */
/* our new node is equivalent to our previous node.                          */
/*                                                                           */
/*****************************************************************************/

test_newnode(_,_,_,_,[],[]):- !.              % Empty node.

test_newnode(_,_,_,_,[[true]],[[true]]):-!.   % Node equivalent to "true"

test_newnode(_,_, PrevNode, _,NewNode,NewNode):-
      same_node(PrevNode,NewNode),!.          % Node equivalent to the previous node.

test_newnode(F,Rules, _, TopNode,NewNode,FinalNode):-
      build_graph(F,Rules, NewNode, TopNode,FinalNode).
                                              % Try and build a new node

/*****************************************************************************/
/* build_node(F,Rules, PrevNode, TopNode,NewNode).                             */
/*                                                                           */
/* To build a new node we take each rule from our global box rules (Rules)   */
/* in turn and check whether its rhs implies the previous node (PrevNode)    */
/* and its lhs implies the top node (TopNode). If the former is the case but */
/* not the latter then the rule is combined with the initial rules (obtained */
/* from TopNode) so the latter holds also. If the rules may be used if       */
/* combined with others they are stored in a separate list and combined at   */
/* the end. The lhs of all the rules which satisfy the above two criteria    */
/* are disjoined and simplified to  create the new node (NewNode).           */
/*                                                                           */
/*****************************************************************************/

build_node(F,Rules, PrevNode, TopNode,FinalNode):-
      flatten(PrevNode,FlatPrev),
      get_relevant_rules(Rules,PrevNode,FlatPrev,TopNode, Useful,[],NewishNode),
      combine_useful_rules(Useful,PrevNode,FlatPrev,TopNode,NewishNode,NewThisNode),
      simplify_new_node(F,NewThisNode,FinalNode).

/*****************************************************************************/
/* combine_useful_rules(Rules, [D1|DRest], PrevNode,TopNode, ThisNode,FinalNode) */
/*                                                                           */
/* Takes all the rules that we think we may be able to combine together so   */
/* the rhs implies the previous node (PrevNode) and its lhs implies the top  */
/* node (TopNode). For disjunct (D1) we separate out all the rules that may  */
/* combine together to give us a D1 on the rhs and then do the same with the */
/* remaining disjuncts. These combined rules are tested to see if the rhs    */
/* implies the previous node (PrevNode) and its lhs implies the top node     */
/* (TopNode) and if so the lhs is returned in FinalNode.                     */
/*                                                                           */
/*****************************************************************************/

combine_useful_rules([],_,_,_, FinalNode,FinalNode):- !.    % We have no useful rules.

combine_useful_rules(Rules, PrevNode,FlatPrev,TopNode,ThisNode,FinalNode):- !,
    split_into_sublists(Rules,FlatPrev,SplitRules),
    combine_for_disjuncts(PrevNode,SplitRules,PrevNode,TopNode,ThisNode,FinalNode).

/*****************************************************************************/
/* get_relevant_rules(Rules,PrevNode,FlatPrev,TopNode,ThisNode,Useful,NewNode). */
/*                                                                           */
/* Takes the set of global box rules (Rules) and extracts rules whose right  */
/* hand sides imply the previous node. If the left hand side of this rule    */
/* also implies the top node then the lhs is added as a disjunct of NewNode. */
/* If the lhs does not it is combined with the lhs of each initial           */
/* rule. Also rules are searched for where the propositions on the rhs of the*/
/* rule are a subset of the proposition in the previous node but the rhs     */
/* does not imply the previous node. Subsets of these are combined in an     */
/* attempt that their rhs will imply the previous node.                      */
/*                                                                           */
/*****************************************************************************/

get_relevant_rules([r(_,_, P imp next Q)|Rest],PrevNode,FlatPrev,TopNode,Useful,ThisNode,FinalNode):-
       strip_or(Q,StrippedQ),            % Rhs => PrevNode & lhs => TopNode
       set_implies(StrippedQ,PrevNode),  % Add lhs to the list for the new node.
       strip_or(P,[StrippedP]),
       set_implies([StrippedP],TopNode),!,
       remove_subsumed(StrippedP,ThisNode,NewThisNode),
       get_relevant_rules(Rest,PrevNode,FlatPrev,TopNode,Useful,NewThisNode,FinalNode).

get_relevant_rules([r(_,_,P imp next Q)|Rest],PrevNode,FlatPrev,TopNode,Useful,ThisNode, FinalNode):-
       strip_or(Q,StrippedQ),             % Rhs => PrevNode & not (lhs => TopNode)
       set_implies(StrippedQ,PrevNode),!, % combine lhs with initial nodes and add.
       strip_or(P,StrippedP),
       combine_lhs_with_initial(StrippedP,TopNode,NewDisjuncts),
       remove_subsumed_list(NewDisjuncts,ThisNode,NewThisNode),
       get_relevant_rules(Rest,PrevNode,FlatPrev,TopNode,Useful,NewThisNode,FinalNode).

get_relevant_rules([r(N1,N2,P imp next Q)|Rest],PrevNode,FlatPrev,TopNode,[r(N1,N2,P imp next Q)|Useful],ThisNode,FinalNode):-
       strip(Q,StrippedQ),
       subset(StrippedQ,FlatPrev),!,      % in the previous node. Save for combining.
       get_relevant_rules(Rest,PrevNode,FlatPrev,TopNode,Useful,ThisNode,FinalNode).

get_relevant_rules([r(_,_,Q)|Rest],PrevNode,FlatPrev,TopNode,Useful,ThisNode,FinalNode):-
       disjunction_of_literals(Q),
       strip_or(Q,StrippedQ),             % Rhs => PrevNode & not (lhs => TopNode)
       set_implies(StrippedQ,PrevNode),!, % combine lhs with initial nodes and add.
       remove_subsumed_list(TopNode,ThisNode,NewThisNode),
       get_relevant_rules(Rest,PrevNode,FlatPrev,TopNode,Useful,NewThisNode,FinalNode).

get_relevant_rules([r(N1,N2,Q)|Rest],PrevNode,FlatPrev,TopNode,[r(N1,N2,Q)|Useful],ThisNode,FinalNode):-
       disjunction_of_literals(Q),
       strip(Q,StrippedQ),
       subset(StrippedQ,FlatPrev),!,      % in the previous node. Save for combining.
       get_relevant_rules(Rest,PrevNode,FlatPrev,TopNode,Useful,ThisNode,FinalNode).

get_relevant_rules([_|Rest],PrevNode,FlatPrev,TopNode,Useful,ThisNode,FinalNode):- !,
        get_relevant_rules(Rest,PrevNode,FlatPrev,TopNode,Useful,ThisNode,FinalNode).
                                        % Not useful.

get_relevant_rules([],_,_,_,[],FinalNode,FinalNode).        % Recursion base case.

/*****************************************************************************/
/* combine_lhs_with_initial(Lhs,TopNode,NewDisjuncts)                        */
/*                                                                           */
/* Takes the left hand side of a rule (Lhs) and the top node and combines    */
/* Lhs with each disjunct of Top Node storing output on NewDisjuncts.        */
/*                                                                           */
/*****************************************************************************/
                                         % This fires if our Conj is just a
                                         % literal and saves doing append. 

combine_lhs_with_initial([[Conj]],[H|Tail],[NewDisjunct|NewDisjuncts]):- !,
     simplify_a_disjunct([Conj|H],NewDisjunct),       
     combine_lhs_with_initial([[Conj]],Tail,NewDisjuncts).

combine_lhs_with_initial([Conj],[H|Tail],[NewDisjunct|NewDisjuncts]):-
     append(Conj,H,NewConj),
     simplify_a_disjunct(NewConj,NewDisjunct),       
     combine_lhs_with_initial([Conj],Tail,NewDisjuncts).

combine_lhs_with_initial(_,[],[]).

/*****************************************************************************/
/* same_node(N1,N2).                                                         */
/*                                                                           */
/* N1 and N2 are lists made up of sublists that represent a formula in DNF.  */
/* To check that N1 and N2 are equivalent we must make sure that N1 => N2    */
/* and N2 => N1 (remembering that we have lists and sublists.                */
/*                                                                           */
/*****************************************************************************/

same_node([],[]):-!.

same_node(List1,List2):-
     set_implies(List1,List2),
     set_implies(List2,List1).
   
/*****************************************************************************/
/* combine_for_disjunct(Rules, D1,PrevNode,TopNode, ThisNode,FinalNode)      */
/*                                                                           */
/* Takes a disjunct D1 from the previous node (PrevNode) and finds all the   */
/* rules from Rules (which is a subset of the set of global box rules of     */
/* rules that do not satisfy our two criteria on the lhs and rhs of rules but*/
/* may be combined together to satisfy these criteria) that may be combined  */
/* together to give us D1. These are then combined together and the left     */
/* hand sides of rules that do satisfy our criteria are returned in          */
/* NewDisjuncts.                                                             */
/*                                                                           */
/*****************************************************************************/

combine_for_disjuncts([D1|Disjuncts],Rules,PrevNode,TopNode,ThisNode,FinalNode):-
     get_rules_for_disjunct(Rules,D1,NewRules),
     combine_rules(Rules,NewRules,D1,PrevNode,TopNode,ThisNode,NewerNode,NewerRules),
     combine_for_disjuncts(Disjuncts, NewerRules,PrevNode,TopNode,NewerNode,FinalNode).

combine_for_disjuncts([], _Rules, _PrevNode, _TopNode, FinalNode,FinalNode).

/*****************************************************************************/
/* get_rules_for_disjunct(Rules, Disjunct,NewRules)                          */
/*                                                                           */
/* Takes the set of rules we think we may be able to combine together (Rules)*/
/* and a disjunct (Disjunct) and we extract the rules that may give us this  */
/* disjunct at least by looking for rules that have a literal or literals on */
/* their rhs in common with the disjunct.                                    */
/*                                                                           */
/*****************************************************************************/

get_rules_for_disjunct([[Lit]|Rest],[Lit|Disjuncts],[NewRest]):- !,   % No rules for Lit
     get_rules_for_disjunct(Rest,Disjuncts,NewRest).

get_rules_for_disjunct([[Lit,Rules]|Rest],[Lit|Disjuncts],[Rules|NewRest]):- !,
     get_rules_for_disjunct(Rest,Disjuncts,NewRest).

get_rules_for_disjunct([[Lit,Rules]|Rest],Disjuncts,[Rules|NewRest]):-
     member(Lit,Disjuncts),!,
     get_rules_for_disjunct(Rest,Disjuncts,NewRest).

get_rules_for_disjunct([[_,_]|Rest],Disjuncts,NewRest):-
     get_rules_for_disjunct(Rest,Disjuncts,NewRest).

get_rules_for_disjunct(_,[],[]).           % Recursion base case.

get_rules_for_disjunct([],_,[]).           % Recursion base case.

/*****************************************************************************/
/* combine_rules(NewRules, PrevNode, TopNode,ThisNode,FinalNode)    */
/*                                                                           */
/* Takes the set of rules that we think we can combine to give us one of the */
/* disjuncts Disjunct, splits them into sublists, one for each literal of the*/
/* disjunct and does the combination by combining one rule form each sublist.*/
/* Each combined rule is checked to see whether its rhs implies the previous */
/* node and its left hands side implies the top node and if so its lhs is    */
/* returned in NewDisjuncts.                                                 */
/*                                                                           */
/*****************************************************************************/

combine_rules(Rules,SplitRules, D1,PrevNode, TopNode,ThisNode,FinalNode,NewRules):-
    combine_sublists(SplitRules,Combined),
    get_relevant_combined(Combined,Rules,D1,PrevNode,TopNode,ThisNode,FinalNode,NewRules).

/*****************************************************************************/
/* split_into_sublists(NewRules,Disjunct,SplitRules)                         */
/*                                                                           */
/* Takes the set of rules that we think we can combine to give us one of the */
/* disjuncts Disjunct, splits them into sublists, one for each literal of the*/
/* disjunct, returning the sublists in SplitRules.                           */
/*                                                                           */
/*****************************************************************************/

split_into_sublists(Rules,[C1|Conjuncts],[[C1,C1Rules]|RestRules]):-
   rules_that_give_a_conjunct(C1,Rules,C1Rules),
   split_into_sublists(Rules,Conjuncts,RestRules).

split_into_sublists(_,[],[]).

/*****************************************************************************/
/* rules_that_give_a_conjunct(C1,Rules,C1Rules)                              */
/*                                                                           */
/* Takes a conjunct C1 from one of the disjuncts of our previous node and    */
/* returns C1Rules, a subset of the rules we give it (Rules) where C1 is a   */
/* member of the set of literals formed from the rhs of a rule.              */
/*                                                                           */
/*****************************************************************************/

rules_that_give_a_conjunct(C1,[r(N1,N2,P imp next Q)|Rest],[r(N1,N2,P imp next Q)|NewRest]):-
   strip(Q,StrippedQ),
   member(C1,StrippedQ),!,
   rules_that_give_a_conjunct(C1,Rest,NewRest).

rules_that_give_a_conjunct(C1,[r(N1,N2,Q)|Rest],[r(N1,N2,Q)|NewRest]):-
   disjunction_of_literals(Q),
   strip(Q,StrippedQ),
   member(C1,StrippedQ),!,
   rules_that_give_a_conjunct(C1,Rest,NewRest).

rules_that_give_a_conjunct(C1,[_|Rest],NewRest):-
   rules_that_give_a_conjunct(C1,Rest,NewRest).

rules_that_give_a_conjunct(_,[],[]).

/*****************************************************************************/
/* combine_sublists(SplitRules,Combined)                                     */
/*                                                                           */
/* Takes a list split into sublists (SplitRules) and combines the rules      */
/* so as to take one from each sublist returning the combined rules in       */
/* Combined.                                                                 */
/*                                                                           */
/*****************************************************************************/

combine_sublists([_],[]):-!.               % Only one sublist

combine_sublists([L1|[L2]],L12):- !,       % Two sublists
   combine_two_sublists(L1,L2,L12).

combine_sublists([L1|L2],NewL1L2):- !,     % More than two sublists
   combine_sublists(L2,NewL2),
   combine_two_sublists(L1,NewL2,NewL1L2).

combine_sublists([],[]).                   % No sublists
/*****************************************************************************/
/* combine_two_sublists(L1,L2,NewL1L2).                                      */
/*                                                                           */
/* Takes two sublists L1 and L2 an combines every rule in L1 with every rule */
/* in L2, returning the combined rules in NewL1L2.                           */
/*                                                                           */
/*****************************************************************************/

combine_two_sublists([H1|Tail1],List2,NewList):-
   combine_element_with_all(H1,List2,H1List2),
   combine_two_sublists(Tail1,List2,Tail1List2),
   append(H1List2,Tail1List2,NewList).

combine_two_sublists([],_,[]).

/*****************************************************************************/
/* combine_element_with_all(H1,List2,H1List2)                                */
/*                                                                           */
/* Takes a rule H1 and combines it with every rule in List2 to give H1List2. */
/*                                                                           */
/*****************************************************************************/

combine_element_with_all(H1,[H2|Tail2],FinalList):-
  combine_two_rules(H1,H2,H1H2),
  test_combine_rules(H1H2,H1,Tail2,FinalList).

combine_element_with_all(_,[],[]).

/****************************************************************************/

test_combine_rules(r(_,_,false imp next _),H1,Tail2,H1Tail2):- !,
  combine_element_with_all(H1,Tail2,H1Tail2).

test_combine_rules(Rule,H1,Tail2,[Rule|H1Tail2]):-
  combine_element_with_all(H1,Tail2,H1Tail2).

/*****************************************************************************/
/* get_relevant_combined(Combined,PrevNode,TopNode,ThisNode,FinalNode).      */
/*                                                                           */
/* Does the same as get_relevent_rules but for those we have combined. We    */
/* search for rules from Combined whose right hand sides imply the previous  */
/* node PrevNode). If the left hand side of the rule also implies the top    */
/* node (TopNode) then the lhs is added as a disjunct of NewDisjuncts.       */
/* If the lhs does not it is combined with the lhs of each initial           */
/* rule and then added to NewDisjuncts.                                      */
/*                                                                           */
/*****************************************************************************/

get_relevant_combined(_,Rules,_,_,_,[[true]],[[true]],Rules):-!.

get_relevant_combined([r(_,_,P imp next Q)|Rest],Rules,D1,PrevNode,TopNode,ThisNode,FinalNode,NewRules):-
       strip_or(Q,StrippedQ),             % Rhs => PrevNode & lhs => TopNode
       set_implies(StrippedQ,PrevNode),   % Add lhs to the list for the new node.
       strip_or(P,[StrippedP]),
       set_implies([StrippedP],TopNode),!,
       remove_subsumed(StrippedP,ThisNode,NewerThisNode),
       get_relevant_combined(Rest,Rules,D1,PrevNode,TopNode,NewerThisNode,FinalNode,NewRules).


get_relevant_combined([r(_,_,P imp next Q)|Rest],Rules,D1,PrevNode,TopNode,ThisNode,FinalNode,NewRules):-
       strip_or(Q,StrippedQ),             % Rhs => PrevNode & not (lhs => TopNode)
       set_implies(StrippedQ,PrevNode),!,   % combine lhs with initial nodes and add.
       strip_or(P,StrippedP),
       combine_lhs_with_initial(StrippedP,TopNode,NewDisjuncts),
       remove_subsumed_list(NewDisjuncts,ThisNode,NewerThisNode),
       get_relevant_combined(Rest,Rules,D1,PrevNode,TopNode,NewerThisNode,FinalNode,NewRules).

get_relevant_combined([r(_,_,Q)|Rest],Rules,D1,PrevNode,TopNode,ThisNode,FinalNode,NewRules):-
       disjunction_of_literals(Q),
       strip_or(Q,StrippedQ),             % Rhs => PrevNode & not (lhs => TopNode)
       set_implies(StrippedQ,PrevNode),!,   % combine lhs with initial nodes and add.
       remove_subsumed_list(TopNode,ThisNode,NewerThisNode),
       get_relevant_combined(Rest,Rules,D1,PrevNode,TopNode,NewerThisNode,FinalNode,NewRules).

get_relevant_combined([Rule|Rest],Rules,D1,PrevNode,TopNode,ThisNode,FinalNode,NewRules):- !,
       add_combined_to_rules(Rule,Rules,D1,PrevNode,NewerRules),
       get_relevant_combined(Rest,NewerRules,D1,PrevNode,TopNode,ThisNode,FinalNode,NewRules).
                                        % Not useful.

get_relevant_combined([],Rules,_,_,_,FinalNode,FinalNode,Rules).         % Recursion base case.
/*****************************************************************************/
/* combine_two_rules(R1,R2,NewRule).                                         */
/*                                                                           */
/* Takes two rules R1 and R2, combines them and simplifies them to give      */
/* NewRule.                                                                  */
/*                                                                           */
/*****************************************************************************/

combine_two_rules(r(N1,_,P imp next F), r(N3,_,Q imp next G), r(N1,[N1,N3],NewLHS imp next RHS)):-
           simplify_and(P and Q, NewerLHS),
           simplify_and_dup(NewerLHS, NewLHS),       
	   simplify_dnf(F and G, RHS).

combine_two_rules(r(N1,_,F), r(N3,_,Q imp next G), r(N1,[N1,N3],Q imp next RHS)):-
           disjunction_of_literals(F),
	   simplify_dnf(F and G, RHS).

combine_two_rules(r(N1,_,P imp next F), r(N3,_,G), r(N1,[N1,N3],P imp next RHS)):-
           disjunction_of_literals(G),
	   simplify_dnf(F and G, RHS).

combine_two_rules(r(N1,_,F), r(N3,_,G), r(N1,[N1,N3],RHS)):-
           disjunction_of_literals(F),
           disjunction_of_literals(G),
	   simplify_dnf(F and G, RHS).

/*****************************************************************************/
/*   simplify_dnf(X,Y)                                                       */
/*                                                                           */
/* Called during the combinations coding (combine_two_rules), as when two    */
/* are combined eg  A imp B, and  X imp Y, we will get                       */
/*  (A and X) imp (B and Y). If B or Y were previously disjunctive           */
/* then the right hand side will need to be converted to DNF and simplified. */
/* This predicate converts to disjunctive normal form, checks for            */
/* complementary literals, or duplicated literals, and removes "false" from  */
/* disjunction.                                                              */
/*                                                                           */
/*****************************************************************************/

simplify_dnf(X,Y):-
  cnf_to_dnf(X,NewX),
  simplifylist(NewX,SimplerX),
  simplify_in_dnf(SimplerX,SimplerDNF),
  simplify_dnf1(SimplerDNF,Y).

/****************************************************************************/

cnf_to_dnf(X,NewX):-
  strip_cnf(X,StrippedX),
  combine_sublists_in_dnf(StrippedX,NewX).

/*****************************************************************************/
/* simply_dnf1(X,Y)                                                          */
/*                                                                           */
/* If the list X is empty returns false otherwise removes duplicate          */
/* disjuncts, and returns Y which has the relevant and and or included.      */                           
/*                                                                           */
/*****************************************************************************/

simplify_dnf1([],false):-!.

simplify_dnf1([true],true):-!.

simplify_dnf1(SimpleX,Y):-
  rewrite_and_or(SimpleX,Y).

/*****************************************************************************/
/* simplify_a_disjunct(Dis,SimpleDis).                                       */
/*                                                                           */
/* Simplifies a single disjunct i.e. removes true, replaces false by false   */
/* removes duplicate literals and replaces complementary literals by false.  */
/*                                                                           */
/*****************************************************************************/

simplify_a_disjunct(Dis,NewDis):-
   simplifylist([Dis],[NewDis]).

/*****************************************************************************/
/*                                                                           */
/*  simplifylist(X,SimplerX)                                                 */
/*  Takes a list X which is of the form [[a,a],[b,a]] (representing dnf on   */
/*  (a or b) and a, which gives us (a and a) or (a and b). It searches each  */
/*  member of the list (ie [a,a] and then [b,a]) for complementary literals  */
/*  and replaces them with false, otherwise it looks for duplicate literals  */
/*  and removes any duplicates. SimplerX is the list which is returned.      */                        
/*                                                                           */
/*****************************************************************************/

simplifylist([H|Tail],[[false]|NewTail]):-
        simplify_and_false(H),!,
        simplifylist(Tail,NewTail).

simplifylist([H|Tail], [[false]|NewTail]):-
        comp_lits_and(H),!,
        simplifylist(Tail, NewTail).

simplifylist([H|Tail], [NewerH|NewTail]):-
        remove_duplicate(H, NewH),!,
        simplify_and_true(NewH,NewerH),
        simplifylist(Tail, NewTail).

simplifylist([],[]).

/*****************************************************************************/
/*    remove_true(X,NewX),                                                   */
/*                                                                           */
/* Takes (X) a list of lists of disjuncts eg [[a],[a,b]] which has had any   */
/* sublists containing complementary literals replaced by "false" and any    */
/* sublists containing occurances of duplicate literals replaced by just a   */
/* single instance of that one instance. It checks X and if it finds "true"  */
/* as a member of the list returns "true" otherwise it returns X.            */
/*                                                                           */
/*****************************************************************************/

remove_true(List,[[true]]):-
    member([true],List),!.

remove_true(List,[[true]]):-
    member([],List),!.

remove_true(List,List):-!.

/*****************************************************************************/
/*    remove_false(X,NewX),                                                  */
/*                                                                           */
/* Takes (X) a list of lists of disjuncts eg [[a],[a,b]] which has had any   */
/* sublists containing complementary literals replaced by "false" and any    */
/* sublists containing occurances of duplicate literals replaced by just a   */
/* single instance of that one instance. It checks X and removes occurances  */
/* of false.                                                                 */
/* N.B. In the case where X is [[false],[false],[false]] the removal of all  */
/* the falses will leave us with the empty list ([]). This is replaced       */
/* by false in simply_dnf1 above.                                            */
/*                                                                           */
/*****************************************************************************/

remove_false([[true]],[[true]]):-!.

remove_false([false|Rest],NewRest):-
   !,remove_false(Rest,NewRest).

remove_false([[false]|Rest],NewRest):-
   !,remove_false(Rest,NewRest).

remove_false([Nodelist|Rest],[Nodelist|NewRest]):-
   !,remove_false(Rest,NewRest).

remove_false([],[]).

/*****************************************************************************/
/* simplify_and_false(List).                                                 */
/*                                                                           */
/* Called from simplifylist. List will be a list of literals (or false) which*/
/* make up a disjunct as part of the right hand side of a (combined) rule    */
/* of the form [a,b,c,neg d,false,f]. If false is a member of this list then */
/* the whole list reduces to false so this predicate succeeds.               */
/*                                                                           */
/*****************************************************************************/

simplify_and_false([false|_]):- !.

simplify_and_false([_|Rest]):-
   simplify_and_false(Rest).

/*****************************************************************************/
/* simplify_and_true(List).                                                  */
/*                                                                           */
/* Called from simplifylist. List will be a list of literals (or false) which*/
/* make up a disjunct as part of the right hand side of a (combined) rule    */
/* of the form [a,b,c,neg d,false,f]. If false is a member of this list then */
/* the whole list reduces to false so this predicate succeeds.               */
/*                                                                           */
/*****************************************************************************/

simplify_and_true([true|Rest],NewRest):- !,
   simplify_and_true(Rest,NewRest).

simplify_and_true([H|Rest],[H|NewRest]):- !,
   simplify_and_true(Rest,NewRest).

simplify_and_true([],[]).

/*****************************************************************************/
/* simplify_top_node(F,ListofDisjuncts,SimplifiedDNF).                         */
/*                                                                           */
/* Simplifies our nodes given that ListofDisjuncts is of the form            */
/* [[..],[..],[..]] where each ... is a list of literal and are supposed to  */
/* conjoined together.                                                       */
/*                                                                           */
/*****************************************************************************/

simplify_top_node(_,[],[]):-!.   % Need this in case initial node is empty.

simplify_top_node(_,[[true]],[[true]]):-!.   
                                 % Need this in case initial node is true.

simplify_top_node(F,ListofDisjuncts,FinalDNF):-
  simplifylist(ListofDisjuncts,SimpleDisjuncts),
  simplify_in_dnf(SimpleDisjuncts,SimplerDNF),
  simplify_comp_lits_in_dnf(SimplerDNF,SimplifiedDNF1),
  simplify_in_dnf(SimplifiedDNF1,SimplifiedDNF),
  remove_bad_disjuncts(F,SimplifiedDNF,FinalDNF).

/*****************************************************************************/
/* simplify_new_node(F,ListofDisjuncts,SimplifiedDNF).                         */
/*                                                                           */
/* Simplifies our nodes given that ListofDisjuncts is of the form            */
/* [[..],[..],[..]] where each ... is a list of literal and are supposed to  */
/* conjoined together.                                                       */
/*                                                                           */
/*****************************************************************************/

simplify_new_node(_,[],[]):-!.   % Need this in case initial node is empty.

simplify_new_node(F,SimplerDNF,FinalDNF):-
  simplify_comp_lits_in_dnf(SimplerDNF,SimplifiedDNF1),
  simplify_in_dnf(SimplifiedDNF1,SimplifiedDNF),
  remove_bad_disjuncts(F,SimplifiedDNF,FinalDNF).


/*****************************************************************************/
/*  remove_bad_disjuncts(F,SimplifiedDNF,FinalDNF).                          */
/*                                                                           */
/*  Takes the eventuality we are resolving with F and the current node in    */
/*  DNF. If any of the disjuncts contain our eventuality then we will never  */
/*  be able to build a rule which has both the eventuality and its negation  */
/*  on the RHS to extend this node so we can just delete this disjunct.      */
/*****************************************************************************/

remove_bad_disjuncts(_,[],[]).

remove_bad_disjuncts(F,[H|Tail],NewTail):-
   member(F,H),!,
   remove_bad_disjuncts(F,Tail,NewTail).

remove_bad_disjuncts(F,[H|Tail],[H|NewTail]):-
   remove_bad_disjuncts(F,Tail,NewTail).

/*****************************************************************************/
/* simplify_in_dnf(List,NewList)                                             */
/*                                                                           */
/* Takes a list of disjuncts each of which have been simplified (removing    */
/* true from conjuncts, making false disjuncts that have false as a conjunct */
/* deleting duplicate literals in variables and replacing complementary      */
/* by false) and simplifies the complete disjunction. This is done by        */
/* replacing the whole disjunction by true is one of the disjuncts is true,  */
/* deleting disjuncts that are false and removing any disjuncts D2 where     */
/* D2 => D1, where D1 is another disjunct.                                   */
/*                                                                           */
/*****************************************************************************/

simplify_in_dnf(List,NewList):-
     remove_true(List,NewerList),
     remove_false(NewerList,NoFalseList),
     order_node(NoFalseList,OrderedList),
     remove_sublists(OrderedList,NewList).

/*****************************************************************************/
/* order_node(Node,NewNode).                                                 */
/*                                                                           */
/* Takes a list made up from sublists (Node) and orders it dependent on the  */
/* length of the sublist. This is to make it easier to remove disjuncts D2   */
/* where D2 => D1.                                                           */
/*                                                                           */
/*****************************************************************************/
order_node([[true]],[[true]]):-!.   % If we have a node (a v ~a) we need this case.

order_node([[false]],[[false]]):-!.

order_node([],[[false]]):-!.

order_node(Node,NewNode):-
   give_length_key_list(Node,KeyList),
   keysort(KeyList,Sorted),
   take_key(Sorted,NewNode).

/*****************************************************************************/
/* give_length_key_list(Node,KeyList)                                        */
/*                                                                           */
/* Gives a key which is the length of the sublist to each sublist.           */
/*                                                                           */
/*****************************************************************************/

give_length_key_list([H|Tail],[Key-H|NewTail]):-
  give_key_length(H,Key),
  give_length_key_list(Tail,NewTail).

give_length_key_list([],[]).
/*****************************************************************************/
/* give_key_length(H,Key)                                                    */
/*                                                                           */
/* Takes a sublist H and calculates its length returning the value in Key.   */    
/*                                                                           */
/*****************************************************************************/
give_key_length([_|Tail],NewKey):-
   give_key_length(Tail,Key),
   NewKey is Key + 1.

give_key_length([],0).
/*****************************************************************************/
/* take_key(List, NewList).                                                  */
/*                                                                           */
/* Takes a list with keys attached for ordering (List) removes the key and   */
/* returns the list in NewList.                                              */
/*                                                                           */
/*****************************************************************************/

take_key([_-H|Tail],[H|NewTail]):-
  take_key(Tail,NewTail).

take_key([],[]).

/*****************************************************************************/
/* remove_sublists(OrderedList,NewList).                                     */
/*                                                                           */
/* Looks for sublists S1 and S2 of OrderedList where S1 is a subset of S2    */
/* deletes S2 from OrderedList until this can be done no more.               */
/*                                                                           */
/*****************************************************************************/

remove_sublists([H|Tail],[H|NewTail]):-
   remove_sublist(H,Tail,NewerTail),
   remove_sublists(NewerTail,NewTail).

remove_sublists([],[]).

/*****************************************************************************/
/*    remove_sublist(H,Tail,NewerTail)                                       */
/*                                                                           */
/* Takes a sublist H and the remaining sublists the same length or longer    */
/* than it, looks for sublists of which H is a subset and deletes them from  */
/* Tail to give NewerTail.                                                   */
/*                                                                           */
/*****************************************************************************/

remove_sublist(H,[H1|Tail],NewTail):-
    subset(H,H1),!,
    remove_sublist(H,Tail,NewTail).

remove_sublist(H,[H1|Tail],[H1|NewTail]):-
    remove_sublist(H,Tail,NewTail).

remove_sublist(_,[],[]).

/*****************************************************************************/
/* simplify_comp_lits_in_dnf(SimplerDNF,SimplifiedDNF1)                      */
/*                                                                           */
/* Looks for literals in a node (in DNF) which are complementary and adds    */
/* new disjuncts that occur if we write from DNF into CNF and back to DNF.   */
/* For example if we have [[s,a],[t,~a]] we add the disjunct [s,t].          */
/*                                                                           */
/*****************************************************************************/

simplify_comp_lits_in_dnf(DNFList,NewList):-
     get_comp_list(DNFList,CompLits),
     add_extra_disjuncts(DNFList,CompLits,NewList).

/*****************************************************************************/
/* get_comp_list(DNFList,CompLits)                                           */
/*                                                                           */
/* Takes all the literals of DNFList and searches for literals where both    */
/* l and ~l are in the list and returns one of this pair in CompLits.        */
/*                                                                           */
/*****************************************************************************/

get_comp_list(DNFList,CompLits):-
   flatten(DNFList,FlatList),
   find_comp_lits(FlatList,CompLits).

/*****************************************************************************/
/*    find_comp_lits(ShortList,CompLits).                                    */
/*                                                                           */
/* Takes a list of literals and their negations. Looks at the each member of */
/* this list in turn and then for its negation in the remainder of the list. */
/* If its negation is found then the literal is added to CompLits.           */
/*                                                                           */
/*****************************************************************************/

find_comp_lits([H|Tail],[H|NewTail]):-
   is_comp_lit(H,Tail),!,
   find_comp_lits(Tail,NewTail).

find_comp_lits([_|Tail],NewTail):-
   find_comp_lits(Tail,NewTail).

find_comp_lits([],[]).
/*****************************************************************************/
/*    is_comp_lit(H,Tail).                                                   */
/*                                                                           */
/* Returns true if the negation of H is a member of Tail.                    */
/*                                                                           */
/*****************************************************************************/

is_comp_lit(H,Tail):-
  snff_negate(H,NegH),
  member(NegH,Tail),!.

/*****************************************************************************/
/* add_extra_disjuncts(DNFList,CompLits,CompLits,NewList).                   */
/*                                                                           */
/* For each pair of complementary literals adds a new disjuncts that occurs  */
/* if we write from DNF into CNF and back to DNF.                            */
/* For example if we have [[s,a],[t,~a]] we add the disjunct [s,t].          */
/*                                                                           */
/*****************************************************************************/

add_extra_disjuncts(List,[H|Tail],NewList):-
   solve_for_comp_lit(H, List, List, NewerList),
   add_extra_disjuncts(NewerList,Tail,NewList).

add_extra_disjuncts(List,[],List).

/*****************************************************************************/
/* solve_for_comp_lit(H, List, NewerList)                                    */
/*                                                                           */
/* Takes a complementary literal, H, the node we have built, List, which is  */
/* in DNF, searches for the first disjuncts from List that have either H or  */
/* ~H as a member. Then the rest of the list is searched for a sublist with  */
/* either ~H or H depending on what our first literal was and adds a new     */
/* disjunct that is the remaining literals from the sublist with the H or ~H */
/* in it and the sublist with the ~H or H in it. This is repeated on the     */
/* remains of the list (after we found the first sublist with H or ~H in).   */
/*                                                                           */
/*****************************************************************************/

solve_for_comp_lit(Comp,[D1|DRest],List,NewestRest):-
    member(Comp,D1),!,
    remove_member(Comp,D1,NewD1),
    snff_negate(Comp,NegComp),
    solve_for_second_comp(NegComp,DRest,List,NewD1,NewList),
    solve_for_comp_lit(Comp,DRest,NewList,NewestRest).

solve_for_comp_lit(Comp,[D1|DRest],List,NewestRest):-
    snff_negate(Comp,NegComp),
    member(NegComp,D1),!,
    remove_member(NegComp,D1,NewD1),
    solve_for_second_comp(Comp,DRest,List,NewD1,NewList),
    solve_for_comp_lit(Comp,DRest,NewList,NewestRest).

solve_for_comp_lit(Comp,[_|DRest],List,NewRest):-
    solve_for_comp_lit(Comp,DRest,List,NewRest).

solve_for_comp_lit(_,[],List,List).

/*****************************************************************************/
/* solve_for_second_comp(Comp,DRest,NewD1,NewerRest)                         */
/*                                                                           */
/* Having found a sublist with ~Comp in we look for the sublist form DRest   */
/* that includes Comp. On finding this sublist we remove Comp from the list  */
/* and append the remaining literals with those remaining from the sublist   */
/* with ~Comp and use this a s a new disjuncts. This is repeated searching   */
/* for any other sublists that may include Comp as a member.                 */
/*                                                                           */
/*****************************************************************************/

solve_for_second_comp(Comp,[[Comp]|_],_,[],[[true]]):- !.
                                   % We have found a literal and its negation.

solve_for_second_comp(Comp,[D1|DRest],All,OldConjuncts,NewestRest):-
    member(Comp,D1),!,
    remove_member(Comp,D1,NewD1),
    append(OldConjuncts,NewD1,NewerConjuncts),
    simplify_a_disjunct(NewerConjuncts,NewConjuncts),
    remove_subsumed(NewConjuncts,All,NewAll),
    solve_for_second_comp(Comp,DRest,NewAll,OldConjuncts,NewestRest).

solve_for_second_comp(Comp,[_|DRest],All,OldConjuncts,NewRest):-
    solve_for_second_comp(Comp,DRest,All,OldConjuncts,NewRest).
    
solve_for_second_comp(_,[],All,_,All).

/******************************************************************************/

remove_subsumed_list([H|Tail],All,FinalAll):-
  remove_subsumed(H,All,NewAll),
  remove_subsumed_list(Tail,NewAll,FinalAll).

remove_subsumed_list([],FinalAll,FinalAll).

/*****************************************************************************/

remove_subsumed([true],_,[[true]]):-!.

remove_subsumed([false],All,All):-!.

remove_subsumed(Dis,[H|Tail],[H|Tail]):-
  subset(H,Dis),!.

remove_subsumed(Dis,[H|Tail],NewTail):-
  subset(Dis,H), !,
  remove_subsumed(Dis, Tail,NewTail).

remove_subsumed(Dis,[H|Tail],[H|NewTail]):-
   remove_subsumed(Dis,Tail,NewTail).
    
remove_subsumed(Dis,[],[Dis]).

/*******************************************************************************/
/* strip_cnf(Clause, List)                                                      */
/*                                                                             */
/*   This predicate removes all ands or ors from Clause which is disjunctive   */
/*   and puts them on a bracketed List eg (a and b) or c would be [[a,b],[c]]  */
/*******************************************************************************/

strip_cnf(A and B,NewAB):- !,
   strip_cnf(A,NewA),
   strip_cnf(B,NewB),
   append(NewA,NewB,NewAB).

strip_cnf(A or B,[NewAB]):- !,
   strip_or(A or B, NewAB).

strip_cnf(A,[[[A]]]).

/*****************************************************************************/
/* combine_sublists_in_dnf(SplitRules,Combined)                              */
/*                                                                           */
/* Takes a list split into sublists (SplitRules) and combines the rules      */
/* so as to take one from each sublist returning the combined rules in       */
/* Combined.                                                                 */
/*                                                                           */
/*****************************************************************************/

combine_sublists_in_dnf([_],[]):-!.               % Only one sublist

combine_sublists_in_dnf([L1|[L2]],L12):- !,       % Two sublists
   combine_two_sublists_in_dnf(L1,L2,L12).

combine_sublists_in_dnf([L1|L2],NewL1L2):- !,     % More than two sublists
   combine_sublists_in_dnf(L2,NewL2),
   combine_two_sublists_in_dnf(L1,NewL2,NewL1L2).

combine_sublists_in_dnf([],[]).                   % No sublists

/*****************************************************************************/
/* combine_two_sublists_in_dnf(L1,L2,NewL1L2).                               */
/*                                                                           */
/* Takes two sublists L1 and L2 an combines every rule in L1 with every rule */
/* in L2, returning the combined rules in NewL1L2.                           */
/*                                                                           */
/*****************************************************************************/

combine_two_sublists_in_dnf([H1|Tail1],List2,NewList):-
   combine_element_with_all_in_dnf(H1,List2,H1List2),
   combine_two_sublists_in_dnf(Tail1,List2,Tail1List2),
   append(H1List2,Tail1List2,NewList).

combine_two_sublists_in_dnf([],_,[]).

/*****************************************************************************/
/* combine_element_with_all_in_dnf(H1,List2,H1List2)                         */
/*                                                                           */
/* Takes a rule H1 and combines it with every rule in List2 to give H1List2. */
/*                                                                           */
/*****************************************************************************/

combine_element_with_all_in_dnf(H1,[H2|Tail2],[H1H2|H1Tail2]):-
  append(H1,H2,H1H2),
  combine_element_with_all_in_dnf(H1,Tail2,H1Tail2).

combine_element_with_all_in_dnf(_,[],[]).

/**********************************************************************/

add_combined_to_rules(r(_,_,false imp next _),Rules,_,_,Rules):- !.

add_combined_to_rules(r(_,_, _ imp next false),Rules,_,_,Rules):- !.

add_combined_to_rules(r(_,_, true imp false),Rules,_,_,Rules):- !.

add_combined_to_rules(r(N1,N2,P imp next Q),Rules,_D1,PrevNode,NewRules):-
   strip_or(Q,StrippedQ),
   remove_ok_disjuncts(StrippedQ,PrevNode,NewStrippedQ),
   flatten(NewStrippedQ,FinalQ),
   add_combined_to_rule(r(N1,N2,P imp next Q),FinalQ,Rules,NewRules).

add_combined_to_rules(r(N1,N2,Q),Rules,_D1,PrevNode,NewRules):-
   disjunction_of_literals(Q),
   strip_or(Q,StrippedQ),
   remove_ok_disjuncts(StrippedQ,PrevNode,NewStrippedQ),
   flatten(NewStrippedQ,FinalQ),
   add_combined_to_rule(r(N1,N2,Q),FinalQ,Rules,NewRules).

add_combined_to_rule(r(N1,N2,P imp next Q),StrippedQ,[[Lit,LitRules]|Rest],[[Lit,NewLitRules]|NewRest]):-
   member(Lit,StrippedQ),!,
   add_combined_rule(r(N1,N2,P imp next Q),LitRules,NewLitRules),
   add_combined_to_rule(r(N1,N2,P imp next Q),StrippedQ,Rest,NewRest).

add_combined_to_rule(r(N1,N2,Q),StrippedQ,[[Lit,LitRules]|Rest],[[Lit,NewLitRules]|NewRest]):-
   disjunction_of_literals(Q),
   member(Lit,StrippedQ),!,
   add_combined_rule(r(N1,N2,Q),LitRules,NewLitRules),
   add_combined_to_rule(r(N1,N2,Q),StrippedQ,Rest,NewRest).

add_combined_to_rule(r(N1,N2,P imp next Q),StrippedQ,[[Lit,LitRules]|Rest],[[Lit,LitRules]|NewRest]):- !,
   add_combined_to_rule(r(N1,N2,P imp next Q),StrippedQ,Rest,NewRest).

add_combined_to_rule(r(N1,N2,Q),StrippedQ,[[Lit,LitRules]|Rest],[[Lit,LitRules]|NewRest]):- 
   disjunction_of_literals(Q),
   add_combined_to_rule(r(N1,N2,Q),StrippedQ,Rest,NewRest).

add_combined_to_rule(r(_,_, _ imp next _),_,[],[]).

add_combined_to_rule(r(_,_,_),_,[],[]).

/***********************************************************************************/

add_combined_rule(r(_,_,P1 imp next Q1),[r(M1,M2,P2 imp next Q2)|LitRest],[r(M1,M2,P2 imp next Q2)|LitRest]):-  
 strip_or(Q1,StrippedQ1),
 strip_or(Q2,StrippedQ2),
 same_node(StrippedQ1,StrippedQ2),
 strip(P1,StrippedP1),
 strip(P2,StrippedP2),
 set_implies(StrippedP1,StrippedP2),!.

add_combined_rule(r(_,_,Q1),[r(M1,M2,P2 imp next Q2)|LitRest],[r(M1,M2,P2 imp next Q2)|LitRest]):-
 disjunction_of_literals(Q1),  
 strip_or(Q1,StrippedQ1),
 strip_or(Q2,StrippedQ2),
 same_node(StrippedQ1,StrippedQ2),
 strip(P2,StrippedP2),
 set_implies([true],StrippedP2),!.

add_combined_rule(r(_,_,_ imp next Q1),[r(M1,M2,Q2)|LitRest],[r(M1,M2,Q2)|LitRest]):-  
 disjunction_of_literals(Q2),
 strip_or(Q1,StrippedQ1),
 strip_or(Q2,StrippedQ2),
 same_node(StrippedQ1,StrippedQ2),!.

add_combined_rule(r(_,_,Q1),[r(M1,M2,Q2)|LitRest],[r(M1,M2,Q2)|LitRest]):-
 disjunction_of_literals(Q1),
 disjunction_of_literals(Q2),  
 strip_or(Q1,StrippedQ1),
 strip_or(Q2,StrippedQ2),
 same_node(StrippedQ1,StrippedQ2),!.

add_combined_rule(r(N1,N2,P1 imp next Q1),[r(_,_,P2 imp next Q2)|LitRest],NewLitRest):-  
 strip_or(Q1,StrippedQ1),
 strip_or(Q2,StrippedQ2),
 same_node(StrippedQ1,StrippedQ2),
 strip(P1,StrippedP1),
 strip(P2,StrippedP2),
 set_implies(StrippedP2,StrippedP1),!,
 add_combined_rule(r(N1,N2,P1 imp next Q1),LitRest,NewLitRest).  

add_combined_rule(r(N1,N2,P1 imp next Q1),[r(_,_,Q2)|LitRest], NewLitRest):-  
 disjunction_of_literals(Q2),
 strip_or(Q1,StrippedQ1),
 strip_or(Q2,StrippedQ2),
 same_node(StrippedQ1,StrippedQ2),
 strip(P1,StrippedP1),
 set_implies([true],StrippedP1),!,
 add_combined_rule(r(N1,N2,P1 imp next Q1),LitRest,NewLitRest).  

add_combined_rule(r(N1,N2,Q1),[r(_,_,_ imp next Q2)|LitRest], NewLitRest):-
 disjunction_of_literals(Q1),  
 strip_or(Q1,StrippedQ1),
 strip_or(Q2,StrippedQ2),
 same_node(StrippedQ1,StrippedQ2),
 add_combined_rule(r(N1,N2,Q1),LitRest,NewLitRest).  
  
add_combined_rule(r(N1,N2,P1 imp next Q1),[r(M1,M2,P2 imp next Q2)|LitRest],[r(M1,M2,P2 imp next Q2)|NewLitRest]):-  
 add_combined_rule(r(N1,N2,P1 imp next Q1),LitRest,NewLitRest).  

add_combined_rule(r(N1,N2,P1 imp next Q1),[r(M1,M2,Q2)|LitRest],[r(M1,M2, Q2)|NewLitRest]):-
 disjunction_of_literals(Q2),  
 add_combined_rule(r(N1,N2,P1 imp next Q1),LitRest,NewLitRest).  

add_combined_rule(r(N1,N2,Q1),[r(M1,M2,P2 imp next Q2)|LitRest],[r(M1,M2, P2 imp next Q2)|NewLitRest]):-  
 disjunction_of_literals(Q1),
 add_combined_rule(r(N1,N2,Q1),LitRest,NewLitRest).  

add_combined_rule(r(N1,N2,Q1),[r(M1,M2,Q2)|LitRest],[r(M1,M2,Q2)|NewLitRest]):- 
 disjunction_of_literals(Q1),
 disjunction_of_literals(Q2), 
 add_combined_rule(r(N1,N2,true imp next Q1),LitRest,NewLitRest).  

add_combined_rule(r(N1,N2,P1 imp next Q1),[],[r(N1,N2,P1 imp next Q1)]).
                              
add_combined_rule(r(N1,N2,Q1),[],[r(N1,N2,Q1)]):-
 disjunction_of_literals(Q1).

/*********************************************************************************************/

remove_ok_disjuncts([H|Rest],Node,NewRest):-
  set_implies(H,Node),!,
  remove_ok_disjuncts(Rest,Node,NewRest).

remove_ok_disjuncts([H|Rest],Node,[H|NewRest]):-
  remove_ok_disjuncts(Rest,Node,NewRest).

remove_ok_disjuncts([],_,[]).
